Real estate broker content types
================================

Realestatebroker has two content types. One for *homes* and one for
*businesses*.

    >>> from collective.realestatebroker.content.residential import Residential
    >>> from collective.realestatebroker.content.commercial import Commercial

Interfaces
----------

Both implement interfaces:

    >>> from collective.realestatebroker.interfaces import IRealEstateContent
    >>> from collective.realestatebroker.interfaces import IResidential
    >>> from collective.realestatebroker.interfaces import ICommercial
    >>> IRealEstateContent.implementedBy(Residential)
    True
    >>> IResidential.implementedBy(Residential)
    True
    >>> IRealEstateContent.implementedBy(Commercial)
    True
    >>> ICommercial.implementedBy(Commercial)
    True

For flash mass-upload we need to implement IUploadingCapable.

    >>> from Products.PloneFlashUpload.interfaces import IUploadingCapable
    >>> IUploadingCapable.implementedBy(Residential)
    True
    >>> IUploadingCapable.implementedBy(Commercial)
    True

Fields
------

By nature, a real estate object deals with a sizeable number of fields
(address, price details, kind of house, extras, etc.). A large number of them
are country-specific. With plone 3.0, there's a fancy way to extend existing
schemas (ISchema), which is made even simpler by the ``schemaextender``
product. We therefore have the luxury of restricting the number of fields and
to suggest integrators to add their own extra fields.

Schemata allow a handy subdivision (especially with plone 3.0's user
interface) of fields, so we'll offer a standard set that can be extended by
custom fields.

- Generic data such as address, description, main text.

- Price information (which has lots of scope for country-specific additions).

- Measurements.

- Object details such as kind of building, construction year, heating system,
  insulation.

- Environment: garden and outside details like description of the environment.

- Location (= google maps).

To be future-proof, we're implementing the content types as archetypes with
zope3 interface around them. Bit of a double work, but OK for now. Let's test
some basic presense of fields:

    >>> residential_schema = Residential.schema
    >>> 'constructYear' in residential_schema
    True
    >>> 'garage' in residential_schema
    True
    >>> 'price' in residential_schema
    True
    >>> 'parking' in residential_schema # from commercial!
    False
    >>> 'parking' in Commercial.schema
    True

There are a lot of fields, so we're subdividing them into schemata, even
though there will probably be custom-made edit forms.

    >>> some_fields = residential_schema.getSchemataFields('default')
    >>> len(some_fields) > 0
    True
    >>> some_fields = residential_schema.getSchemataFields('financial')
    >>> len(some_fields) > 0
    True
    >>> some_fields = residential_schema.getSchemataFields('non-existing')
    >>> len(some_fields) > 0
    False

Schema extension
----------------

Real estate objects are very locale-dependent. So it will be necessary to do
customization to the fields. archetypes.schemaextender is a great tool for
that. To demonstrate the use, the actual Dutch customization that Zest
software made for a Dutch customer is included as an example. Which means that
we can test it. The field we'll test on is called ``kk_von``, which won't make
sense unless you're Dutch :-)

First we ensure that the field isn't available yet.

    >>> res = Residential('res')
    Traceback (most recent call last):
    ...
    TypeError: ('Could not adapt', <Residential at >, <InterfaceClass Products.Archetypes.interfaces._schema.ISchema>)

Ouch, this is a unittest, so the zcml-loaded ISchema adapter doesn't work
yet. We'll have to enable it by hand.

    >>> from Products.Archetypes.Schema.factory import instanceSchemaFactory
    >>> from zope import component
    >>> component.provideAdapter(instanceSchemaFactory)

To prevent that we need to make too much mock objects, we'll need to remove
the fieldproperties as they require too much wiring.

    >>> from Products.Archetypes.atapi import ATFieldProperty
    >>> for attr in ['address', 'description', 'zipcode', 'city', 'price', 'house_type', 'rooms', 'text', 'acceptance', 'area', 'floor_area', 'volume', 'construct_year', 'location', 'kind_of_building', 'heating', 'insulation', 'garden', 'kind_of_garden', 'storage', 'kind_of_storage', 'garage', 'kind_of_garage']:
    ...     delattr(Residential, attr)

So, now we can grab the schema the official way.

    >>> res = Residential('res')
    >>> schema = res.Schema()
    >>> 'price' in schema
    True
    >>> 'kk_von' in schema
    False